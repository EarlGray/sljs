<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="sljs - a naïve, primitive, savage JavaScript interpreter library."><title>sljs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="sljs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.1 (7cf61ebde 2024-03-27)" data-channel="1.77.1" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../sljs/index.html">sljs</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../sljs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">sljs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/sljs/lib.rs.html#1-31">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>sljs - a naïve, primitive, savage JavaScript interpreter library.</p>
<h3 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting started</h3>
<p>sljs does not contains a lexical JavaScript parser: it consumes an AST tree supplied in the
<a href="https://github.com/estree/estree/blob/master/es5.md">ESTree format</a>.</p>
<p>When compiled with <code>feature = [&quot;std&quot;]</code> (used by default), sljs provides <a href="runtime/struct.Runtime.html" title="struct sljs::runtime::Runtime"><code>runtime::Runtime</code></a>
abstraction that bundles an external JavaScript parser, a way to execute it and the interpreter
itself.</p>
<p>There are two <a href="runtime/trait.Parser.html" title="trait sljs::runtime::Parser"><code>runtime::Parser</code></a>s at the moment, both using a JavaScript parser written in
JavaScript called <a href="https://esprima.org/">Esprima</a>:</p>
<ul>
<li>
<p><a href="runtime/struct.NodejsParser.html" title="struct sljs::runtime::NodejsParser"><code>runtime::NodejsParser</code></a>: it runs Esprima in an external nodejs runtime to parse input into
ESTree-structured JSON abstract syntax tree (AST), loaded and executed by the interpreter.</p>
</li>
<li>
<p>experimental <a href="runtime/struct.EsprimaParser.html" title="struct sljs::runtime::EsprimaParser"><code>runtime::EsprimaParser</code></a>: it runs a JSON dump of Esprima’s AST bundled within
the interpreter in the interpreter itself. It takes input and produces a AST directly on
the heap of the interpreter. It is obviously slow and unstable at the moment: many methods
of the builtin JavaScript objects like String/Object/Number/etc are not implemented yet.</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sljs::JSValue;
<span class="kw">use </span>sljs::runtime::{Runtime, EsprimaParser};

<span class="kw">let </span>parser = Box::new(EsprimaParser::new());
<span class="kw">let </span><span class="kw-2">mut </span>runtime = Runtime::load(parser).expect(<span class="string">"Runtime::load"</span>);

runtime.evaluate(<span class="string">"var x = 2, y = 2"</span>).expect(<span class="string">"eval: var x, y"</span>);
runtime.evaluate(<span class="string">"function add(a, b) { return a + b }"</span>).expect(<span class="string">"eval: add"</span>);
<span class="kw">let </span>result: JSValue = runtime.evaluate(<span class="string">"add(x, y)"</span>).expect(<span class="string">"eval: x + y"</span>);

<span class="macro">assert_eq!</span>(result, JSValue::from(<span class="number">4</span>));</code></pre></div>
<h3 id="a-more-detailed-usage-example"><a class="doc-anchor" href="#a-more-detailed-usage-example">§</a>A more detailed usage example</h3>
<p>If you don’t use the default features (i.e. <code>features = [&quot;std&quot;]</code>), <a href="runtime/struct.Runtime.html" title="struct sljs::runtime::Runtime"><code>runtime::Runtime</code></a> is not
available. In that case you have to do the grunt work yourself:</p>
<ul>
<li>supply an ESTree AST</li>
<li>parse it into a <a href="ast/struct.Program.html" title="struct sljs::ast::Program"><code>Program</code></a></li>
<li>execute the program on a <a href="heap/struct.Heap.html" title="struct sljs::heap::Heap"><code>Heap</code></a>.</li>
</ul>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sljs::{JSON, Heap};      <span class="comment">// an alias for `serde_json::Value`

// JavaScript: "2 + 2"
</span><span class="kw">let </span>estree: JSON = serde_json::from_str(<span class="string">r#"{
  "type": "Program",
  "body": [
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "BinaryExpression",
        "operator": "+",
        "left": { "type": "Literal", "value": 2 },
        "right": { "type": "Literal", "value": 2 }
      }
    }
  ]
}"#</span>).expect(<span class="string">"JSON"</span>);</code></pre></div>
<p><a href="ast/struct.Program.html#method.parse_from" title="associated function sljs::ast::Program::parse_from"><code>Program::parse_from</code></a> can parse any representation of ESTree that implements the
<a href="trait.SourceNode.html" title="trait sljs::SourceNode"><code>SourceNode</code></a> trait; a reference implementation is provided for <code>sljs::JSON</code> (an alias for
<code>serde_json::Value</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>program = Program::parse_from(<span class="kw-2">&amp;</span>estree).expect(<span class="string">"ESTree"</span>);</code></pre></div>
<p>To run a <a href="ast/struct.Program.html" title="struct sljs::ast::Program"><code>Program</code></a>, create a <a href="heap/struct.Heap.html" title="struct sljs::heap::Heap"><code>Heap</code></a> (it’s roughly a vector of
<a href="object/struct.JSObject.html" title="struct sljs::object::JSObject"><code>JSObject</code></a>s with its indexes encapsulated in <a href="heap/struct.JSRef.html" title="struct sljs::heap::JSRef"><code>JSRef</code></a>s) and interpret
the <code>program</code> on this <code>heap</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// builtin objects like Object, String, etc, are initialized here:
</span><span class="kw">let </span><span class="kw-2">mut </span>heap = Heap::new();

<span class="kw">let </span>result: JSValue = <span class="kw">match </span>heap.evaluate(<span class="kw-2">&amp;</span>program) {
    <span class="prelude-val">Ok</span>(result) =&gt; result,
    <span class="prelude-val">Err</span>(exc) =&gt; {
        <span class="macro">eprintln!</span>(<span class="string">"Exception: {:?}"</span>, exc);
        <span class="kw">return</span>;
    }
};
<span class="macro">assert_eq!</span>(result, JSValue::from(<span class="number">4</span>));</code></pre></div>
<p>A value of type <a href="object/enum.Interpreted.html" title="enum sljs::object::Interpreted"><code>Interpreted</code></a> is usually a wrapper for a <a href="value/enum.JSValue.html" title="enum sljs::value::JSValue"><code>JSValue</code></a>,
although it might represent an object member that does not exist yet (which evaluates to
<code>JSValue::Undefined</code> when reading):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>result: Interpreted = program.interpret(<span class="kw-2">&amp;mut </span>heap).expect(<span class="string">"interpret()"</span>);
<span class="kw">let </span>value: JSValue = result.to_value(<span class="kw-2">&amp;</span>heap).expect(<span class="string">"JSValue"</span>);
<span class="macro">assert_eq!</span>(value, JSValue::from(<span class="number">4</span>));

<span class="kw">let </span>output = value.to_string(<span class="kw-2">&amp;mut </span>heap).unwrap();
<span class="macro">assert_eq!</span>(output.as_str(), <span class="string">"4"</span>);</code></pre></div>
<h3 id="more-about-objects"><a class="doc-anchor" href="#more-about-objects">§</a>More about objects</h3>
<p><a href="object/struct.JSObject.html" title="struct sljs::object::JSObject"><code>JSObject</code></a> contains:</p>
<ul>
<li>a <a href="heap/struct.JSRef.html" title="struct sljs::heap::JSRef"><code>JSRef</code></a> to its prototype object</li>
<li>optionally an <a href="object/enum.ObjectValue.html" title="enum sljs::object::ObjectValue"><code>object::ObjectValue</code></a> encapsulatng a primitive value,
or a <a href="function/struct.HostFunc.html" title="struct sljs::function::HostFunc"><code>function::HostFunc</code></a>/<a href="function/struct.Closure.html" title="struct sljs::function::Closure"><code>function::Closure</code></a>, or an optimized object storage
(e.g. <a href="object/struct.JSArray.html" title="struct sljs::object::JSArray"><code>object::JSArray</code></a>)</li>
<li>a hashmap from <code>String</code> keys to <a href="object/struct.Property.html" title="struct sljs::object::Property"><code>object::Property</code></a></li>
</ul>
<p>Each <a href="object/struct.Property.html" title="struct sljs::object::Property"><code>object::Property</code></a> consists of:</p>
<ul>
<li><a href="object/struct.Access.html" title="struct sljs::object::Access"><code>object::Access</code></a> that determines if property is enumerable, writable, configurable;</li>
<li><a href="object/enum.Content.html" title="enum sljs::object::Content"><code>object::Content</code></a> that encapsulates a way to get and/or set a <a href="value/enum.JSValue.html" title="enum sljs::value::JSValue"><code>JSValue</code></a>.</li>
</ul>
<p>TODO: more about JSObject API</p>
<h3 id="functions-and-closures"><a class="doc-anchor" href="#functions-and-closures">§</a>Functions and closures</h3>
<p>An example of calling a JavaScript closure from Rust using <a href="heap/struct.Heap.html#method.execute" title="method sljs::heap::Heap::execute"><code>Heap::execute</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sljs::<span class="kw-2">*</span>;

<span class="comment">// function zoom(size) { return 1.1 * size; }
</span><span class="kw">let </span>estree: JSON = serde_json::from_str(<span class="string">r#"{
  "type": "Program",
  "body": [{
      "type": "FunctionDeclaration",
      "id": { "type": "Identifier", "name": "zoom" },
      "params": [{"type": "Identifier", "name": "size"}],
      "body": {
        "type": "BlockStatement",
        "body": [{
          "type": "ReturnStatement",
          "argument": {
            "type": "BinaryExpression",
            "operator": "*",
            "left": { "type": "Literal", "value": 1.1 },
            "right": { "type": "Identifier", "name": "size" }
          }
        }]
      }
  }]
}"#</span>).expect(<span class="string">"JSON"</span>);
<span class="kw">let </span>zoom_decl = Program::parse_from(<span class="kw-2">&amp;</span>estree).expect(<span class="string">"ESTree"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>heap = Heap::new();

<span class="comment">// Create a function object for `zoom`:
</span>zoom_decl.interpret(<span class="kw-2">&amp;mut </span>heap).unwrap();

<span class="comment">// Get a reference to the `zoom` function object:
</span><span class="kw">let </span>zoomref: JSRef = heap
    .lookup_path(<span class="kw-2">&amp;</span>[<span class="string">"zoom"</span>])     <span class="comment">// or `&amp;["global", "zoom"]` for `global.zoom`
    </span>.expect(<span class="string">"zoom function"</span>)    <span class="comment">// : Interpreted
    </span>.to_ref(<span class="kw-2">&amp;</span>heap).expect(<span class="string">"reference"</span>);

<span class="comment">// Finally, call `zoom(10)`:
</span><span class="kw">let </span>call = CallContext::from(<span class="macro">vec!</span>[Interpreted::from(<span class="number">10</span>)])
    .with_this(Heap::GLOBAL)
    .with_name(<span class="string">"zoom"</span>.into());
<span class="kw">let </span>result: Interpreted = heap.execute(zoomref, call).expect(<span class="string">"call result"</span>);

<span class="kw">let </span>result: JSValue = result.to_value(<span class="kw-2">&amp;</span>heap).unwrap();
<span class="macro">assert_eq!</span>(result, JSValue::from(<span class="number">11.0</span>));</code></pre></div>
<h3 id="errors-and-exceptions"><a class="doc-anchor" href="#errors-and-exceptions">§</a>Errors and exceptions</h3>
<p>Most functions return a <a href="error/type.JSResult.html" title="type sljs::error::JSResult"><code>JSResult&lt;T&gt;</code></a>, an alias for <code>Result&lt;T, Exception&gt;</code>. An <a href="error/enum.Exception.html" title="enum sljs::error::Exception"><code>Exception</code></a>
can wrap:</p>
<ul>
<li><a href="error/enum.Exception.html#variant.UserThrown" title="variant sljs::error::Exception::UserThrown"><code>Exception::UserThrown</code></a> produced by a <code>throw</code> in JavaScript</li>
<li><a href="error/enum.Exception.html#variant.Syntax" title="variant sljs::error::Exception::Syntax"><code>Exception::Syntax</code></a> wrapping a <a href="error/enum.ParseError.html" title="enum sljs::error::ParseError"><code>error::ParseError</code></a></li>
<li>builtin errors, e.g. <a href="error/enum.Exception.html#variant.Reference" title="variant sljs::error::Exception::Reference"><code>Exception::Reference</code></a>, etc.</li>
</ul>
<p><a href="runtime/enum.EvalError.html" title="enum sljs::runtime::EvalError"><code>runtime::EvalError</code></a> is a wrapper over <a href="error/enum.Exception.html" title="enum sljs::error::Exception"><code>Exception</code></a>, serde (de)serialization errors, I/O
errors when executing an external parser.</p>
<h3 id="what-it-can-do"><a class="doc-anchor" href="#what-it-can-do">§</a>What it can do?</h3>
<p>See <a href="../src/sljs/test.rs.html">src/test.rs</a>, all uncommented tests in there should work.</p>
<h3 id="what-is-not-done-yet"><a class="doc-anchor" href="#what-is-not-done-yet">§</a>What is not done yet?</h3>
<ul>
<li>garbage collection;</li>
<li>any kind of meaningful performance optimization;</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Program"><code>pub use ast::<a class="struct" href="ast/struct.Program.html" title="struct sljs::ast::Program">Program</a>;</code></div></li><li><div class="item-name" id="reexport.Exception"><code>pub use error::<a class="enum" href="error/enum.Exception.html" title="enum sljs::error::Exception">Exception</a>;</code></div></li><li><div class="item-name" id="reexport.JSResult"><code>pub use error::<a class="type" href="error/type.JSResult.html" title="type sljs::error::JSResult">JSResult</a>;</code></div></li><li><div class="item-name" id="reexport.Jump"><code>pub use error::<a class="enum" href="error/enum.Jump.html" title="enum sljs::error::Jump">Jump</a>;</code></div></li><li><div class="item-name" id="reexport.CallContext"><code>pub use function::<a class="struct" href="function/struct.CallContext.html" title="struct sljs::function::CallContext">CallContext</a>;</code></div></li><li><div class="item-name" id="reexport.HostFn"><code>pub use function::<a class="type" href="function/type.HostFn.html" title="type sljs::function::HostFn">HostFn</a>;</code></div></li><li><div class="item-name" id="reexport.HostFunc"><code>pub use function::<a class="struct" href="function/struct.HostFunc.html" title="struct sljs::function::HostFunc">HostFunc</a>;</code></div></li><li><div class="item-name" id="reexport.Heap"><code>pub use heap::<a class="struct" href="heap/struct.Heap.html" title="struct sljs::heap::Heap">Heap</a>;</code></div></li><li><div class="item-name" id="reexport.JSRef"><code>pub use heap::<a class="struct" href="heap/struct.JSRef.html" title="struct sljs::heap::JSRef">JSRef</a>;</code></div></li><li><div class="item-name" id="reexport.Interpretable"><code>pub use interpret::<a class="trait" href="interpret/trait.Interpretable.html" title="trait sljs::interpret::Interpretable">Interpretable</a>;</code></div></li><li><div class="item-name" id="reexport.Interpreted"><code>pub use object::<a class="enum" href="object/enum.Interpreted.html" title="enum sljs::object::Interpreted">Interpreted</a>;</code></div></li><li><div class="item-name" id="reexport.JSObject"><code>pub use object::<a class="struct" href="object/struct.JSObject.html" title="struct sljs::object::JSObject">JSObject</a>;</code></div></li><li><div class="item-name" id="reexport.JSNumber"><code>pub use value::<a class="type" href="value/type.JSNumber.html" title="type sljs::value::JSNumber">JSNumber</a>;</code></div></li><li><div class="item-name" id="reexport.JSString"><code>pub use value::<a class="struct" href="value/struct.JSString.html" title="struct sljs::value::JSString">JSString</a>;</code></div></li><li><div class="item-name" id="reexport.JSValue"><code>pub use value::<a class="enum" href="value/enum.JSValue.html" title="enum sljs::value::JSValue">JSValue</a>;</code></div></li><li><div class="item-name" id="reexport.JSON"><code>pub use value::<a class="type" href="value/type.JSON.html" title="type sljs::value::JSON">JSON</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="ast/index.html" title="mod sljs::ast">ast</a></div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod sljs::error">error</a></div></li><li><div class="item-name"><a class="mod" href="function/index.html" title="mod sljs::function">function</a></div></li><li><div class="item-name"><a class="mod" href="heap/index.html" title="mod sljs::heap">heap</a></div></li><li><div class="item-name"><a class="mod" href="interpret/index.html" title="mod sljs::interpret">interpret</a></div></li><li><div class="item-name"><a class="mod" href="object/index.html" title="mod sljs::object">object</a></div></li><li><div class="item-name"><a class="mod" href="runtime/index.html" title="mod sljs::runtime">runtime</a></div></li><li><div class="item-name"><a class="mod" href="source/index.html" title="mod sljs::source">source</a></div></li><li><div class="item-name"><a class="mod" href="value/index.html" title="mod sljs::value">value</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.HeapNode.html" title="struct sljs::HeapNode">HeapNode</a></div><div class="desc docblock-short"><code>HeapNode</code> contains a heap reference and a <code>JSRef</code> to an AST subtree in it.
It implements <a href="trait.SourceNode.html" title="trait sljs::SourceNode"><code>SourceNode</code></a> for on-heap AST trees.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.SourceNode.html" title="trait sljs::SourceNode">SourceNode</a></div><div class="desc docblock-short"><code>SourceNode</code> is how <code>ParseFrom::parse_from</code> sees AST nodes.</div></li><li><div class="item-name"><a class="trait" href="trait.ToESTree.html" title="trait sljs::ToESTree">ToESTree</a></div><div class="desc docblock-short">ToESTree de-parses an AST struct into its Esprima representation.</div></li></ul></section></div></main></body></html>